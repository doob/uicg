---
import { cva, type VariantProps } from 'class-variance-authority'
import { twMerge } from 'tailwind-merge'

export interface TextareaProps extends Omit<HTMLTextAreaElement, 'size'>, VariantProps<typeof textareaVariants> {
  class?: string
  placeholder?: string
  value?: string
  disabled?: boolean
  required?: boolean
  readonly?: boolean
  rows?: number
  cols?: number
  maxLength?: number
  minLength?: number
  autoResize?: boolean
  resize?: 'none' | 'vertical' | 'horizontal' | 'both'
  size?: 'small' | 'medium' | 'large'
  intent?: 'default' | 'primary' | 'success' | 'warning' | 'danger'
  label?: string
  description?: string
  error?: string
  showCharacterCount?: boolean
}

const textareaVariants = cva(
  'block w-full rounded-md border bg-white px-3 py-2 text-gray-900 shadow-sm placeholder:text-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 disabled:bg-gray-50',
  {
    variants: {
      size: {
        small: 'px-2 py-1 text-sm min-h-[60px]',
        medium: 'px-3 py-2 text-sm min-h-[80px]',
        large: 'px-4 py-3 text-base min-h-[100px]',
      },
      intent: {
        default: 'border-gray-300 focus:border-indigo-500 focus:ring-indigo-500',
        primary: 'border-indigo-300 focus:border-indigo-500 focus:ring-indigo-500',
        success: 'border-green-300 focus:border-green-500 focus:ring-green-500',
        warning: 'border-yellow-300 focus:border-yellow-500 focus:ring-yellow-500',
        danger: 'border-red-300 focus:border-red-500 focus:ring-red-500',
      },
      resize: {
        none: 'resize-none',
        vertical: 'resize-y',
        horizontal: 'resize-x',
        both: 'resize',
      },
      disabled: {
        true: 'cursor-not-allowed opacity-50 bg-gray-50',
        false: '',
      },
      readonly: {
        true: 'bg-gray-50 cursor-default',
        false: '',
      },
      hasError: {
        true: 'border-red-300 focus:border-red-500 focus:ring-red-500',
        false: '',
      },
    },
    compoundVariants: [
      {
        disabled: false,
        readonly: false,
        class: 'dark:border-white/10 dark:bg-white/5 dark:text-white dark:placeholder:text-gray-500 dark:focus:border-indigo-400 dark:focus:ring-indigo-400',
      },
      {
        hasError: true,
        class: 'dark:border-red-400 dark:focus:border-red-400 dark:focus:ring-red-400',
      },
      {
        readonly: true,
        class: 'dark:bg-white/5',
      },
    ],
    defaultVariants: {
      size: 'medium',
      intent: 'default',
      resize: 'vertical',
      disabled: false,
      readonly: false,
      hasError: false,
    },
  }
)

const labelVariants = cva('block text-sm font-medium leading-6', {
  variants: {
    intent: {
      default: 'text-gray-900 dark:text-white',
      primary: 'text-gray-900 dark:text-white',
      success: 'text-gray-900 dark:text-white',
      warning: 'text-gray-900 dark:text-white',
      danger: 'text-red-700 dark:text-red-400',
    },
    required: {
      true: "after:content-['*'] after:ml-0.5 after:text-red-500",
      false: '',
    },
  },
  defaultVariants: {
    intent: 'default',
    required: false,
  },
})

const descriptionVariants = cva('mt-1 text-sm', {
  variants: {
    intent: {
      default: 'text-gray-600 dark:text-gray-400',
      primary: 'text-gray-600 dark:text-gray-400',
      success: 'text-gray-600 dark:text-gray-400',
      warning: 'text-gray-600 dark:text-gray-400',
      danger: 'text-red-600 dark:text-red-400',
    },
  },
  defaultVariants: {
    intent: 'default',
  },
})

const characterCountVariants = cva('mt-1 text-xs', {
  variants: {
    intent: {
      default: 'text-gray-500 dark:text-gray-400',
      warning: 'text-yellow-600 dark:text-yellow-400',
      danger: 'text-red-600 dark:text-red-400',
    },
  },
  defaultVariants: {
    intent: 'default',
  },
})

const {
  class: className,
  placeholder,
  value = '',
  disabled = false,
  required = false,
  readonly = false,
  rows = 4,
  cols,
  maxLength,
  minLength,
  autoResize = false,
  resize = 'vertical',
  size = 'medium',
  intent = 'default',
  label,
  description,
  error,
  showCharacterCount = false,
  ...props
} = Astro.props

const hasError = !!error
const textareaId = `textarea-${Math.random().toString(36).substr(2, 9)}`
const descriptionId = description ? `desc-${textareaId}` : undefined
const errorId = error ? `error-${textareaId}` : undefined
const characterCountId = showCharacterCount ? `count-${textareaId}` : undefined

// Calculate character count intent
const currentLength = typeof value === 'string' ? value.length : 0
const maxLen = maxLength || 0
let countIntent = 'default'

if (maxLength) {
  const percentage = (currentLength / maxLength) * 100
  if (percentage >= 90) {
    countIntent = 'danger'
  } else if (percentage >= 75) {
    countIntent = 'warning'
  }
}
---

<div class="w-full">
  {
    label && (
      <label for={textareaId} class={labelVariants({ intent: hasError ? 'danger' : intent, required })}>
        {label}
      </label>
    )
  }

  <div class="relative mt-1">
    <textarea
      id={textareaId}
      class={twMerge(
        textareaVariants({
          size,
          intent: hasError ? 'danger' : intent,
          resize: autoResize ? 'none' : resize,
          disabled,
          readonly,
          hasError,
        }),
        className
      )}
      placeholder={placeholder}
      value={value}
      disabled={disabled}
      readonly={readonly}
      required={required}
      rows={rows}
      cols={cols}
      maxlength={maxLength}
      minlength={minLength}
      aria-invalid={hasError}
      aria-describedby={[descriptionId, errorId, characterCountId].filter(Boolean).join(' ') || undefined}
      data-auto-resize={autoResize}
      data-textarea-id={textareaId}
      {...props}></textarea>
  </div>

  <div class="mt-1 flex items-start justify-between">
    <div class="flex-1">
      {
        description && !error && (
          <p id={descriptionId} class={descriptionVariants({ intent })}>
            {description}
          </p>
        )
      }

      {
        error && (
          <p id={errorId} class={descriptionVariants({ intent: 'danger' })} role="alert">
            {error}
          </p>
        )
      }
    </div>

    {
      showCharacterCount && (
        <div id={characterCountId} class={characterCountVariants({ intent: countIntent })}>
          <span data-character-count={textareaId}>{currentLength}</span>
          {maxLength && <span>/{maxLength}</span>}
        </div>
      )
    }
  </div>
</div>

<script>
  interface TextareaState {
    element: HTMLTextAreaElement
    autoResize: boolean
    maxLength?: number
    showCharacterCount: boolean
    characterCountElement?: HTMLElement
  }

  class TextareaManager {
    private textareas = new Map<string, TextareaState>()

    constructor() {
      this.init()
    }

    private init() {
      document.addEventListener('DOMContentLoaded', () => {
        this.setupTextareas()
      })

      // Handle dynamic content
      const observer = new MutationObserver(() => {
        this.setupTextareas()
      })
      observer.observe(document.body, { childList: true, subtree: true })
    }

    private setupTextareas() {
      const textareas = document.querySelectorAll('textarea[data-textarea-id]')

      textareas.forEach((textarea) => {
        const element = textarea as HTMLTextAreaElement
        const textareaId = element.getAttribute('data-textarea-id')
        if (!textareaId || this.textareas.has(textareaId)) return

        const autoResize = element.getAttribute('data-auto-resize') === 'true'
        const maxLength = element.maxLength > 0 ? element.maxLength : undefined
        const characterCountElement = document.querySelector(`[data-character-count="${textareaId}"]`) as HTMLElement
        const showCharacterCount = !!characterCountElement

        const state: TextareaState = {
          element,
          autoResize,
          maxLength,
          showCharacterCount,
          characterCountElement,
        }

        this.textareas.set(textareaId, state)
        this.setupTextareaEvents(textareaId, state)

        // Initial setup
        if (autoResize) {
          this.adjustHeight(state)
        }
        if (showCharacterCount) {
          this.updateCharacterCount(state)
        }
      })
    }

    private setupTextareaEvents(textareaId: string, state: TextareaState) {
      const { element } = state

      // Input event for auto-resize and character count
      element.addEventListener('input', () => {
        if (state.autoResize) {
          this.adjustHeight(state)
        }
        if (state.showCharacterCount) {
          this.updateCharacterCount(state)
        }
      })

      // Paste event for auto-resize
      if (state.autoResize) {
        element.addEventListener('paste', () => {
          // Use setTimeout to ensure the pasted content is processed
          setTimeout(() => {
            this.adjustHeight(state)
          }, 0)
        })
      }

      // Window resize event for auto-resize textareas
      if (state.autoResize) {
        window.addEventListener('resize', () => {
          this.adjustHeight(state)
        })
      }
    }

    private adjustHeight(state: TextareaState) {
      const { element } = state

      // Reset height to auto to get the correct scrollHeight
      element.style.height = 'auto'

      // Calculate the new height based on content
      const newHeight = Math.max(element.scrollHeight, this.getMinHeight(element))

      // Set the new height
      element.style.height = `${newHeight}px`
    }

    private getMinHeight(element: HTMLTextAreaElement): number {
      const computedStyle = window.getComputedStyle(element)
      const fontSize = parseInt(computedStyle.fontSize)
      const lineHeight = computedStyle.lineHeight === 'normal' ? fontSize * 1.2 : parseFloat(computedStyle.lineHeight)
      const paddingTop = parseInt(computedStyle.paddingTop)
      const paddingBottom = parseInt(computedStyle.paddingBottom)
      const borderTop = parseInt(computedStyle.borderTopWidth)
      const borderBottom = parseInt(computedStyle.borderBottomWidth)

      // Calculate minimum height based on rows attribute or default
      const rows = parseInt(element.getAttribute('rows') || '4')
      const contentHeight = rows * lineHeight

      return contentHeight + paddingTop + paddingBottom + borderTop + borderBottom
    }

    private updateCharacterCount(state: TextareaState) {
      const { element, characterCountElement, maxLength } = state

      if (!characterCountElement) return

      const currentLength = element.value.length
      characterCountElement.textContent = currentLength.toString()

      // Update character count styling based on percentage
      if (maxLength) {
        const percentage = (currentLength / maxLength) * 100
        const container = characterCountElement.closest('[id*="count-"]')

        if (container) {
          // Remove existing intent classes
          container.classList.remove('text-gray-500', 'dark:text-gray-400', 'text-yellow-600', 'dark:text-yellow-400', 'text-red-600', 'dark:text-red-400')

          // Add appropriate intent classes
          if (percentage >= 90) {
            container.classList.add('text-red-600', 'dark:text-red-400')
          } else if (percentage >= 75) {
            container.classList.add('text-yellow-600', 'dark:text-yellow-400')
          } else {
            container.classList.add('text-gray-500', 'dark:text-gray-400')
          }
        }
      }
    }
  }

  // Initialize the textarea manager
  new TextareaManager()
</script>
